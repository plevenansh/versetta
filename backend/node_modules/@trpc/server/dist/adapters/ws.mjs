import { getErrorShape } from '../unstable-core-do-not-import/error/getErrorShape.mjs';
import { TRPCError, getTRPCErrorFromUnknown } from '../unstable-core-do-not-import/error/TRPCError.mjs';
import { run, isAsyncIterable, isObject } from '../unstable-core-do-not-import/utils.mjs';
import { parseConnectionParamsFromUnknown } from '../unstable-core-do-not-import/http/parseConnectionParams.mjs';
import { parseTRPCMessage } from '../unstable-core-do-not-import/rpc/parseTRPCMessage.mjs';
import { isObservable, observableToAsyncIterable } from '../observable/observable.mjs';
import { transformTRPCResponse } from '../unstable-core-do-not-import/transformer.mjs';
import { toURL } from '../unstable-core-do-not-import/http/toURL.mjs';
import '../unstable-core-do-not-import/rootConfig.mjs';
import { callProcedure } from '../unstable-core-do-not-import/router.mjs';

/**
 * Importing ws causes a build error
 * @link https://github.com/trpc/trpc/pull/5279
 */ const WEBSOCKET_OPEN = 1; /* ws.WebSocket.OPEN */ 
const unsetContextSymbol = Symbol('unsetContext');
function getWSConnectionHandler(opts) {
    const { createContext , router  } = opts;
    const { transformer  } = router._def._config;
    return async (client, req)=>{
        const clientSubscriptions = new Map();
        function respond(untransformedJSON) {
            client.send(JSON.stringify(transformTRPCResponse(router._def._config, untransformedJSON)));
        }
        function createCtxPromise(getConnectionParams) {
            return run(async ()=>{
                ctx = await createContext?.({
                    req,
                    res: client,
                    info: {
                        connectionParams: getConnectionParams(),
                        calls: [],
                        isBatchCall: false,
                        accept: null,
                        type: 'unknown'
                    }
                });
                return ctx;
            }).catch((cause)=>{
                const error = getTRPCErrorFromUnknown(cause);
                opts.onError?.({
                    error,
                    path: undefined,
                    type: 'unknown',
                    ctx,
                    req,
                    input: undefined
                });
                respond({
                    id: null,
                    error: getErrorShape({
                        config: router._def._config,
                        error,
                        type: 'unknown',
                        path: undefined,
                        input: undefined,
                        ctx
                    })
                });
                // close in next tick
                (global.setImmediate ?? global.setTimeout)(()=>{
                    client.close();
                });
                throw error;
            });
        }
        /**
     * promise for initializing the context
     *
     * - the context promise will be created immediately on connection if no connectionParams are expected
     * - if connection params are expected, they will be created once received
     */ let ctxPromise = toURL(req.url ?? '').searchParams.get('connectionParams') === '1' ? unsetContextSymbol : createCtxPromise(()=>null);
        let ctx = undefined;
        async function handleRequest(msg) {
            const { id , jsonrpc  } = msg;
            /* istanbul ignore next -- @preserve */ if (id === null) {
                throw new TRPCError({
                    code: 'BAD_REQUEST',
                    message: '`id` is required'
                });
            }
            if (msg.method === 'subscription.stop') {
                clientSubscriptions.get(id)?.abort();
                return;
            }
            const { path , input  } = msg.params;
            const type = msg.method;
            try {
                await ctxPromise; // asserts context has been set
                const result = await callProcedure({
                    procedures: router._def.procedures,
                    path,
                    getRawInput: async ()=>input,
                    ctx,
                    type
                });
                if (type !== 'subscription') {
                    // send the value as data if the method is not a subscription
                    respond({
                        id,
                        jsonrpc,
                        result: {
                            type: 'data',
                            data: result
                        }
                    });
                    return;
                }
                if (!isObservable(result) && !isAsyncIterable(result)) {
                    throw new TRPCError({
                        message: `Subscription ${path} did not return an observable or a AsyncGenerator`,
                        code: 'INTERNAL_SERVER_ERROR'
                    });
                }
                /* istanbul ignore next -- @preserve */ if (client.readyState !== WEBSOCKET_OPEN) {
                    // if the client got disconnected whilst initializing the subscription
                    // no need to send stopped message if the client is disconnected
                    return;
                }
                /* istanbul ignore next -- @preserve */ if (clientSubscriptions.has(id)) {
                    // duplicate request ids for client
                    throw new TRPCError({
                        message: `Duplicate id ${id}`,
                        code: 'BAD_REQUEST'
                    });
                }
                const iterable = isObservable(result) ? observableToAsyncIterable(result) : result;
                const iterator = iterable[Symbol.asyncIterator]();
                const abortController = new AbortController();
                const abortPromise = new Promise((resolve)=>{
                    abortController.signal.onabort = ()=>resolve('abort');
                });
                run(async ()=>{
                    while(true){
                        const next = await Promise.race([
                            iterator.next().catch(getTRPCErrorFromUnknown),
                            abortPromise
                        ]);
                        if (next === 'abort') {
                            await iterator.return?.();
                            break;
                        }
                        if (next instanceof Error) {
                            const error = getTRPCErrorFromUnknown(next);
                            opts.onError?.({
                                error,
                                path,
                                type,
                                ctx,
                                req,
                                input
                            });
                            respond({
                                id,
                                jsonrpc,
                                error: getErrorShape({
                                    config: router._def._config,
                                    error,
                                    type,
                                    path,
                                    input,
                                    ctx
                                })
                            });
                            break;
                        }
                        if (next.done) {
                            break;
                        }
                        respond({
                            id,
                            jsonrpc,
                            result: {
                                type: 'data',
                                data: next.value
                            }
                        });
                    }
                    await iterator.return?.();
                    respond({
                        id,
                        jsonrpc,
                        result: {
                            type: 'stopped'
                        }
                    });
                    clientSubscriptions.delete(id);
                }).catch((cause)=>{
                    const error = getTRPCErrorFromUnknown(cause);
                    opts.onError?.({
                        error,
                        path,
                        type,
                        ctx,
                        req,
                        input
                    });
                    respond({
                        id,
                        jsonrpc,
                        error: getErrorShape({
                            config: router._def._config,
                            error,
                            type,
                            path,
                            input,
                            ctx
                        })
                    });
                    abortController.abort();
                });
                clientSubscriptions.set(id, abortController);
                respond({
                    id,
                    jsonrpc,
                    result: {
                        type: 'started'
                    }
                });
            } catch (cause) /* istanbul ignore next -- @preserve */ {
                // procedure threw an error
                const error = getTRPCErrorFromUnknown(cause);
                opts.onError?.({
                    error,
                    path,
                    type,
                    ctx,
                    req,
                    input
                });
                respond({
                    id,
                    jsonrpc,
                    error: getErrorShape({
                        config: router._def._config,
                        error,
                        type,
                        path,
                        input,
                        ctx
                    })
                });
            }
        }
        client.on('message', async (message)=>{
            if (ctxPromise === unsetContextSymbol) {
                // If the ctxPromise wasn't created immediately, we're expecting the first message to be a TRPCConnectionParamsMessage
                ctxPromise = createCtxPromise(()=>{
                    let msg;
                    try {
                        msg = JSON.parse(message.toString());
                        if (!isObject(msg)) {
                            throw new Error('Message was not an object');
                        }
                    } catch (cause) {
                        throw new TRPCError({
                            code: 'PARSE_ERROR',
                            message: `Malformed TRPCConnectionParamsMessage`,
                            cause
                        });
                    }
                    const connectionParams = parseConnectionParamsFromUnknown(msg.data);
                    return connectionParams;
                });
                return;
            }
            try {
                const msgJSON = JSON.parse(message.toString());
                const msgs = Array.isArray(msgJSON) ? msgJSON : [
                    msgJSON
                ];
                const promises = msgs.map((raw)=>parseTRPCMessage(raw, transformer)).map(handleRequest);
                await Promise.all(promises);
            } catch (cause) {
                const error = new TRPCError({
                    code: 'PARSE_ERROR',
                    cause
                });
                respond({
                    id: null,
                    error: getErrorShape({
                        config: router._def._config,
                        error,
                        type: 'unknown',
                        path: undefined,
                        input: undefined,
                        ctx: undefined
                    })
                });
            }
        });
        // WebSocket errors should be handled, as otherwise unhandled exceptions will crash Node.js.
        // This line was introduced after the following error brought down production systems:
        // "RangeError: Invalid WebSocket frame: RSV2 and RSV3 must be clear"
        // Here is the relevant discussion: https://github.com/websockets/ws/issues/1354#issuecomment-774616962
        client.on('error', (cause)=>{
            opts.onError?.({
                ctx,
                error: getTRPCErrorFromUnknown(cause),
                input: undefined,
                path: undefined,
                type: 'unknown',
                req
            });
        });
        client.once('close', ()=>{
            for (const sub of clientSubscriptions.values()){
                sub.abort();
            }
            clientSubscriptions.clear();
        });
        if (ctxPromise !== unsetContextSymbol) {
            // prevent unhandled promise rejection errors
            await ctxPromise.catch(()=>null);
        }
    };
}
/**
 * Handle WebSocket keep-alive messages
 */ function handleKeepAlive(client, pingMs = 30000, pongWaitMs = 5000) {
    let heartbeatTimeout;
    const heartbeatInterval = setInterval(()=>{
        if (client.readyState !== WEBSOCKET_OPEN) {
            return;
        }
        // First we send a ping message and wait for a pong
        client.ping();
        // We set a timeout to close the connection if the pong is not received
        heartbeatTimeout = setTimeout(()=>{
            client.terminate();
            clearInterval(heartbeatInterval);
        }, pongWaitMs);
    }, pingMs).unref();
    // When we receive a pong message, we clear the timeout
    client.on('pong', ()=>{
        heartbeatTimeout && clearTimeout(heartbeatTimeout);
    });
    // If the connection is closed, we clear the interval
    client.on('close', ()=>{
        clearInterval(heartbeatInterval);
    });
}
function applyWSSHandler(opts) {
    const { wss , prefix , keepAlive  } = opts;
    const onConnection = getWSConnectionHandler(opts);
    wss.on('connection', async (client, req)=>{
        if (prefix && !req.url?.startsWith(prefix)) {
            return;
        }
        await onConnection(client, req);
        if (keepAlive?.enabled) {
            const { pingMs , pongWaitMs  } = keepAlive;
            handleKeepAlive(client, pingMs, pongWaitMs);
        }
    });
    return {
        broadcastReconnectNotification: ()=>{
            const response = {
                id: null,
                method: 'reconnect'
            };
            const data = JSON.stringify(response);
            for (const client of wss.clients){
                if (client.readyState === WEBSOCKET_OPEN) {
                    client.send(data);
                }
            }
        }
    };
}

export { applyWSSHandler, getWSConnectionHandler };
